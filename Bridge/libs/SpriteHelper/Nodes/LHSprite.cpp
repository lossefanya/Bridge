//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#include "LHSprite.h"
#include "../SpriteHelperLoader.h"
#include "LHAnimationNode.h"
#include "LHSettings.h"
#include "LHBatch.h"
#include "../Utilities/LHDictionary.h"
#include "../Utilities/LHArray.h"
#include "../Utilities/LHObject.h"
#include "LHFixture.h"
#include "SHDocumentLoader.h"

static int untitledSpritesCount = 0;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
LHSprite::~LHSprite(void){
    
    //    CCLog("LH SPRITE %s dealloc", uniqueName.c_str());
    
    if(fixturesInfo){
        delete fixturesInfo;
        fixturesInfo = NULL;
    }
    
    
    unscheduleAllSelectors();
    stopAnimation();
    stopAllActions();
    removeBodyFromWorld();
    
    if(fixturesObj)
        delete fixturesObj;
}
//------------------------------------------------------------------------------
void LHSprite::removeSelf(){
    
    if(body){
        if(body->GetWorld()->IsLocked()){
            LHSettings::sharedInstance()->markNodeForRemoval(this);
            return;
        }
    }
    removeFromParentAndCleanup(true);
}
//void LHSprite::onExit(){
//    //    CCLog("LH SPrite %s onExit", uniqueName.c_str());
//    removeTouchObserver();
//}
//------------------------------------------------------------------------------
LHSprite::LHSprite(){
    
    //CCLog("LHSprite init");
    fixturesInfo = NULL;
    fixturesObj = NULL;
    body = NULL;
    animation = NULL;    
}
//------------------------------------------------------------------------------
void LHSprite::createFixturesFromInfoOnBody(){
    
    if(fixturesInfo && fixturesObj)
    {
        fixturesObj->removeAllObjects();
        
        if(body->GetWorld()->IsLocked())
        {
            CCLog("ERROR: Cannot create fixture for body, because Box2d is Locked. Try changing the location on where you want to change the body. e.g Try doing it at the end of tick function");
            return;
        }
        
        b2Fixture* curFixture = body->GetFixtureList();
        
        while(curFixture)
        {
            b2Fixture* tempNextFix = curFixture->GetNext();
            body->DestroyFixture(curFixture);
            curFixture = tempNextFix;
        }
        
        for(int i = 0; i< fixturesInfo->count(); ++i)
        {
            
            LHDictionary* fixInfo = fixturesInfo->dictAtIndex(i);
            
            LHFixture* lhFixture = LHFixture::fixtureWithDictionary(fixInfo, body, this);
            fixturesObj->addObject(lhFixture);
        }
    }
}
//------------------------------------------------------------------------------
void LHSprite::loadPhysicalInformationFromDictionary(LHDictionary* dictionary){
    
    fixturesInfo = NULL;
    body = NULL;
    
    if(NULL == dictionary)
        return;
    
    b2World* world = LHSettings::sharedInstance()->getActiveBox2dWorld();
    
    if(world == NULL)
        return;
    
    b2BodyDef bodyDef;
	
    int pType = dictionary->intForKey("Type");//LH
    
	if(pType == 3) //"NO_PHYSIC"
        return;
    
	bodyDef.type = (b2BodyType)pType;
	
	CCPoint pos = getPosition();
	bodyDef.position.Set(pos.x/LHSettings::sharedInstance()->lhPtmRatio(),
                         pos.y/LHSettings::sharedInstance()->lhPtmRatio());
    
	bodyDef.angle = CC_DEGREES_TO_RADIANS(-1*getRotation());
    
    
    bodyDef.userData = this;
    
    
    body = world->CreateBody(&bodyDef);
	body->SetFixedRotation(dictionary->boolForKey("FixedRot"));
    
    body->SetGravityScale(dictionary->floatForKey("GravityScale"));
	body->SetSleepingAllowed(dictionary->boolForKey("CanSleep"));
    body->SetBullet(dictionary->boolForKey("IsBullet"));
    
    CCPoint linearVelocity = dictionary->pointForKey("LinearVelocity");
    body->SetLinearVelocity(b2Vec2(linearVelocity.x, linearVelocity.y));
    
    body->SetAngularVelocity(dictionary->floatForKey("AngularVelocity"));
    body->SetLinearDamping(dictionary->floatForKey("LinearDamping"));
    body->SetAngularDamping(dictionary->floatForKey("AngularDamping"));
    
    
    LHArray* fixInfo = dictionary->arrayForKey("SH_ComplexShapes");
    fixturesInfo = new LHArray(fixInfo);
    
#if COCOS2D_VERSION >= 0x00020000
    fixturesObj = CCArray::create();
#else
    fixturesObj = CCArray::array();
#endif
    fixturesObj->retain();
    
    createFixturesFromInfoOnBody();
}
//------------------------------------------------------------------------------
void LHSprite::loadAnimationsInformationFromDictionary(LHDictionary* dictionary){
    
    if(dictionary ==NULL) return; //When sprite is loaded from SH dictionary this info is not available;
    
    //if sprite has no animation dictionary will be empty in order to make the level size smaller
    //so we test here to see if we should load anything
    if(!dictionary->objectForKey("AnimName")) return;
    
    prepareAnimationNamed(dictionary->stringForKey("AnimName"), dictionary->stringForKey("SHScene"));
    
    if(!animation) return;//something has gone wrong with animation loading
    
    if(dictionary->boolForKey("AnimAtStart"))//we should pause the animation
        animation->play();
    
    //dictionary->print();
    
    animation->setLoop(dictionary->boolForKey("AnimLoop"));
    animation->setRepetitions((int)dictionary->intForKey("AnimRepetitions"));
    animation->setRestoreOriginalFrame(dictionary->boolForKey("AnimRestoreOriginalFrame"));
    animation->setDelayPerUnit(dictionary->floatForKey("AnimSpeed"));
}
//------------------------------------------------------------------------------
void LHSprite::loadInformationFromDictionary(LHDictionary* dictionary){
    
    body = NULL;
    
    if(dictionary->objectForKey("UniqueName")){
        uniqueName = std::string(dictionary->stringForKey("UniqueName"));
    }else {
        uniqueName = "UntitledSprite_" + SpriteHelperLoader::stringFromInt(untitledSpritesCount);
        ++untitledSpritesCount;
    }
    
    if(dictionary->objectForKey("SHSceneName"))
        shSceneName = std::string(dictionary->stringForKey("SHSceneName"));
    
    if(dictionary->objectForKey("SHSheetName"))
        shSheetName = std::string(dictionary->stringForKey("SHSheetName"));
    
    if(dictionary->objectForKey("SHSpriteName"))
        shSpriteName= std::string(dictionary->stringForKey("SHSpriteName"));
    
    LHDictionary* texDict = dictionary->dictForKey("TextureProperties");
    
    LHDictionary* shTexDict = texDict;
    
    if(!dictionary->objectForKey("IsSHSprite"))//we may be loading directly from a sh dictionary
    {
        LHDictionary* shDict = SHDocumentLoader::sharedInstance()->dictionaryForSpriteNamed(dictionary->stringForKey("SHSpriteName"),
                                                                                            dictionary->stringForKey("SHSheetName"),
                                                                                            dictionary->stringForKey("SHSceneName"));
        
        if(shDict)
            shTexDict = shDict->dictForKey("TextureProperties");
    }
    
    CCRect rectInPixels = shTexDict->rectForKey("Frame");
    
    // [[LHSettings sharedInstance] transformedTextureRect:self.textureRect forImage:[self imageFile]];
    
    rectInPixels = CC_RECT_POINTS_TO_PIXELS(getTextureRect());
    
    CCSize contentSize = shTexDict->sizeForKey("SpriteSize");
    
    contentSize = LHSettings::sharedInstance()->transformedSize(contentSize,getImageFile());
    contentSize.width *= CC_CONTENT_SCALE_FACTOR();
    contentSize.height*= CC_CONTENT_SCALE_FACTOR();
    
    CCPoint originalTextureOffset = shTexDict->pointForKey("TextureOffset");
    CCSize texOffsetSize = LHSettings::sharedInstance()->transformedSize(CCSizeMake(originalTextureOffset.x,
                                                                                    originalTextureOffset.y),
                                                                         getImageFile());
    originalTextureOffset.x = texOffsetSize.width;
    originalTextureOffset.y = texOffsetSize.height;
    originalTextureOffset.x *= CC_CONTENT_SCALE_FACTOR();
    originalTextureOffset.y *= CC_CONTENT_SCALE_FACTOR();

#if COCOS2D_VERSION >= 0x00020100
    CCSpriteFrame* sprFrame = CCSpriteFrame::createWithTexture(getTexture(),
                                                    rectInPixels,
                                                    shTexDict->boolForKey("IsRotated"),
                                                    originalTextureOffset,
                                                    contentSize);
    
#elif COCOS2D_VERSION == 0x00020000
    CCSpriteFrame* sprFrame = CCSpriteFrame::create(getTexture(),
                                                    rectInPixels,
                                                    shTexDict->boolForKey("IsRotated"),
                                                    originalTextureOffset,
                                                    contentSize);
#else
    CCSpriteFrame* sprFrame = CCSpriteFrame::frameWithTexture(getTexture(),
                                                              rectInPixels,
                                                              shTexDict->boolForKey("IsRotated"),
                                                              originalTextureOffset,
                                                              contentSize);
#endif
    
    setDisplayFrame(sprFrame);
    
    bool flipX = texDict->boolForKey("FlipX");
    bool flipY = texDict->boolForKey("FlipY");
    
    setFlipX(flipX);
    setFlipY(flipY);
    
    CCPoint scale = LHSettings::sharedInstance()->transformedScalePointToCocos2d(texDict->pointForKey("Scale"));
    setScaleX(scale.x);
    setScaleY(scale.y);
    
    realScale = CCSizeMake(scale.x*LHSettings::sharedInstance()->convertRatio().x,
                           scale.y*LHSettings::sharedInstance()->convertRatio().y);
    
    CCPoint position = LHSettings::sharedInstance()->transformedPointToCocos2d(texDict->pointForKey("Position"));
    
    setPosition(ccp((int)position.x, (int)position.y));
    
    
    setRotation(texDict->intForKey("Angle"));
    setColor(texDict->colorForKey("Color"));
    
#if COCOS2D_VERSION >= 0x00020000
    setVisible(texDict->boolForKey("IsDrawable"));
#else
    setIsVisible(texDict->boolForKey("IsDrawable"));
#endif
    
    setOpacity(texDict->floatForKey("Opacity")*255.0f);
    setTag(texDict->intForKey("Tag"));
    m_nZOrder = texDict->intForKey("ZOrder");
    
    LHDictionary* phyDict = dictionary->dictForKey("PhysicProperties");
    if(phyDict->boolForKey("HandledBySH") && !dictionary->objectForKey("IsSHSprite"))
    {
        LHDictionary* sprDict = SHDocumentLoader::sharedInstance()->dictionaryForSpriteNamed(shSpriteName,shSheetName,shSceneName);
        phyDict = sprDict->dictForKey("PhysicProperties");
    }
    
    //we do this because we need the batch to contain the sprite before loading any animation
#if COCOS2D_VERSION >= 0x00020000
    if(getBatchNode()){
        getBatchNode()->addChild(this, m_nZOrder);
    }
#else
    if(getSpriteBatchNode()){
        getSpriteBatchNode()->addChild(this, m_nZOrder);
    }
#endif
    
    originalRect = getTextureRect();
    
    fixturesObj = NULL;
    
    loadPhysicalInformationFromDictionary(phyDict);
    loadAnimationsInformationFromDictionary(dictionary->dictForKey("AnimationsProperties"));
        
    usesOverloadedTransformations = false;
    
    scheduleUpdate();
}
//------------------------------------------------------------------------------
bool LHSprite::initBatchSpriteWithDictionary(LHDictionary* dictionary, LHBatch* batch){
    
    LHDictionary* texDict = dictionary->dictForKey("TextureProperties");
    CCRect rect = texDict->rectForKey("Frame");
    
    rect = LHSettings::sharedInstance()->transformedTextureRect(rect, batch->getImagePath());
    
    if(initWithTexture(batch->getTexture(), rect))
    {
        setImageFile(batch->getImagePath());
        loadInformationFromDictionary(dictionary);
        return true;
    }
    return false;
}
//------------------------------------------------------------------------------
bool LHSprite::initWithDictionary(LHDictionary* dictionary){
    
    std::string imgPath = LHSettings::sharedInstance()->imagePath(dictionary->stringForKey("SheetImage"));
    
    if(imgPath == "")
        return false;
    
    
    LHDictionary* texDict = dictionary->dictForKey("TextureProperties");
    CCRect rect = texDict->rectForKey("Frame");
    
    rect = LHSettings::sharedInstance()->transformedTextureRect(rect,imgPath);
    
    if(initWithFile(imgPath.c_str(), rect))
    {
        setImageFile(imgPath);
        loadInformationFromDictionary(dictionary);
        
        return true;
    }
    
    return false;
}
//------------------------------------------------------------------------------
LHSprite* LHSprite::batchSpriteWithDictionary(LHDictionary* dictionary, LHBatch* batch){
    LHSprite *pobNode = new LHSprite();
	if (pobNode && pobNode->initBatchSpriteWithDictionary(dictionary, batch))
    {
	    pobNode->autorelease();
        pobNode->postInit();
        return pobNode;
    }
    CC_SAFE_DELETE(pobNode);
	return NULL;
}
//------------------------------------------------------------------------------
LHSprite* LHSprite::spriteWithDictionary(LHDictionary* dictionary){
    LHSprite *pobNode = new LHSprite();
	if (pobNode && pobNode->initWithDictionary(dictionary))
    {
	    pobNode->autorelease();
        pobNode->postInit();
        return pobNode;
    }
    CC_SAFE_DELETE(pobNode);
	return NULL;
}
LHSprite* LHSprite::spriteWithTexture(CCTexture2D* texture)
{
    LHSprite *pobNode = new LHSprite();
	if (pobNode && pobNode->initWithTexture(texture))
    {
	    pobNode->autorelease();
        pobNode->postInit();
        return pobNode;
    }
    CC_SAFE_DELETE(pobNode);
	return NULL;
}
//------------------------------------------------------------------------------
LHSprite* LHSprite::spriteWithName(const std::string& spriteName, const std::string& sheetName, const std::string& spriteHelperFile){
    
    LHDictionary* dictionary = SHDocumentLoader::sharedInstance()->dictionaryForSpriteNamed(spriteName,sheetName, spriteHelperFile);
    
    LHSprite* sprite = LHSprite::spriteWithDictionary(dictionary);
    
    if(sprite){
        sprite->setShSceneName(spriteHelperFile);
        sprite->postInit();
    }
    return sprite;
}
//------------------------------------------------------------------------------
LHSprite* LHSprite::batchSpriteWithName(const std::string& spriteName, LHBatch* batch){
    
    CCAssert(batch!=NULL, "Batch must not be nil");
    
    LHDictionary* dictionary = SHDocumentLoader::sharedInstance()->dictionaryForSpriteNamed(spriteName,batch->getUniqueName(),batch->getSHFile());
    LHSprite* sprite = LHSprite::batchSpriteWithDictionary(dictionary,batch);
    
    if(sprite){
        sprite->setShSceneName(batch->getSHFile());
        sprite->postInit();
    }
    return sprite;
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
void LHSprite::update(float dt){
    
    if(animation){
        animation->update(dt);
    }
    LHSettings::sharedInstance()->removeMarkedNodes();
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
void LHSprite::prepareAnimationNamed(const std::string& animName, const std::string& shScene){
    
    LHDictionary* animDict = SHDocumentLoader::sharedInstance()->dictionaryForAnimationNamed(animName,shScene);
    if(animation){
        delete animation;
        animation = NULL;
    }
    
    if(!animDict) {
        CCLog("ERROR: SpriteHelper document %s for animation %s needs to be updated. Animation is canceled.", shScene.c_str(), animName.c_str());
        return;
    }
    
    std::string textureFile = animDict->stringForKey("SheetImage");
    std::string animSheet   = animDict->stringForKey("SheetName");
    
    animation = new LHAnimationNode(animDict, this);
    
    if(shSheetName != animSheet)
    {
        if(textureFile != "")
        {
#if COCOS2D_VERSION >= 0x00020100
            const char* filePath = CCFileUtils::sharedFileUtils()->fullPathForFilename(textureFile.c_str()).c_str();

#elif COCOS2D_VERSION >= 0x00020000
            
            const char* filePath = CCFileUtils::sharedFileUtils()->fullPathFromRelativePath(textureFile.c_str());
#else
            
            const char* filePath = CCFileUtils::fullPathFromRelativePath(textureFile.c_str());
#endif
            
            
            if(filePath){
                CCTexture2D* newTexture = CCTextureCache::sharedTextureCache()->addImage(filePath);
                
                if(newTexture){
                    //if sprite is render by a batch node we need to remove if from the batch and
                    //move it on the layer that contains the batch
#if COCOS2D_VERSION >= 0x00020000
                    LHBatch* parentBatch = (LHBatch*)getBatchNode();
#else
                    LHBatch* parentBatch = (LHBatch*)getSpriteBatchNode();
#endif
                    
                    if(parentBatch){
                        removeFromParentAndCleanup(false);
                        
                        animation->setOldBatch(parentBatch);
                        //we need to keep the z order so its batch z + sprite z
                        if(parentBatch->getParent()){
                            parentBatch->getParent()->addChild(this, parentBatch->getZOrder() + getZOrder());
                        }
                        else {
                            CCLog("ERROR: Sprite is render by batch node, but batch node has no parent.");
                        }
                    }
                    else {
                        animation->setOldTexture(getTexture());
                    }
                    
                    setTexture(newTexture);
                    shSheetName = animSheet;
                }
            }
        }
        else{
            if(animation)
                delete animation;
            
            CCLog("ERROR: Image file %s could not be found. Please add it in the resource folder.", textureFile.c_str());
        }
    }
    
    if(animation){
        animation->setOldRect(originalRect);
        animation->prepare();
    }
}
//------------------------------------------------------------------------------
void LHSprite::playAnimation(){ if(animation)animation->play();}
//------------------------------------------------------------------------------
void LHSprite::pauseAnimation(){ if(animation)animation->setPaused(true);}
//------------------------------------------------------------------------------
void LHSprite::restartAnimation(){ if(animation)animation->restart();}
//------------------------------------------------------------------------------
bool LHSprite::isAnimationPaused(){ if(!animation)return false;
    return animation->getPaused();
}
//------------------------------------------------------------------------------
void LHSprite::stopAnimation(){
    
    if(!animation)return;
    
    animation->setPaused(true);
    animation->restoreFrame();
    
    delete animation;
    animation = NULL;
}
//------------------------------------------------------------------------------
std::string LHSprite::animationName(){ if(animation) return animation->getUniqueName();
    return std::string("");
}
//------------------------------------------------------------------------------
int LHSprite::numberOfFrames(){ if(animation)return animation->getNumberOfFrames();
    return -1;
}
//------------------------------------------------------------------------------
float LHSprite::animationDelayPerUnit(){
    if(animation){return animation->getDelayPerUnit();}
    return 0.0f;
}
void LHSprite::setAnimationDelayPerUnit(float d){
    if(animation){ if(d < 0.0f) d = 0.0f; animation->setDelayPerUnit(d);}
}
//------------------------------------------------------------------------------
std::vector<std::string> LHSprite::getCurrentFrameDataKeys(){
    if(animation){
        LHDictionary* dict = animation->getUserDataForCurrentFrame();
        if(dict){
            return dict->allKeys();
        }
    }
    return std::vector<std::string>();
}
//------------------------------------------------------------------------------
float LHSprite::getCurrentFrameFloatDataForKey(const std::string& key){
    if(animation){
        LHDictionary* dict = animation->getUserDataForCurrentFrame();
        if(dict){
            return dict->floatForKey(key);
        }
    }
    return -1;
}
//------------------------------------------------------------------------------
std::string LHSprite::getCurrentFrameStringDataForKey(const std::string& key){
    if(animation){
        LHDictionary* dict = animation->getUserDataForCurrentFrame();
        if(dict){
            return dict->stringForKey(key);
        }
    }
    return std::string();
}
//------------------------------------------------------------------------------
bool LHSprite::getCurrentFrameBoolDataForKey(const std::string& key){
    if(animation){
        LHDictionary* dict = animation->getUserDataForCurrentFrame();
        if(dict){
            return dict->boolForKey(key);
        }
    }
    return false;
}
//------------------------------------------------------------------------------
bool LHSprite::isCurrentFrameValueForKeyFloat(const std::string& key){
    if(animation){
        LHDictionary* dict = animation->getUserDataForCurrentFrame();
        if(dict){
            LHObject* obj = dict->objectForKey(key);
            if(obj){
                return obj->type() == LHObject::FLOAT_TYPE;
            }
        }
    }
    return false;
}
//------------------------------------------------------------------------------
bool LHSprite::isCurrentFrameValueForKeyString(const std::string& key){
    if(animation){
        LHDictionary* dict = animation->getUserDataForCurrentFrame();
        if(dict){
            LHObject* obj = dict->objectForKey(key);
            if(obj){
                return obj->type() == LHObject::STRING_TYPE;
            }
        }
    }
    return false;
}
//------------------------------------------------------------------------------
bool LHSprite::isCurrentFrameValueForKeyBool(const std::string& key){
    if(animation){
        LHDictionary* dict = animation->getUserDataForCurrentFrame();
        if(dict){
            LHObject* obj = dict->objectForKey(key);
            if(obj){
                return obj->type() == LHObject::BOOL_TYPE;
            }
        }
    }
    return false;
}
//------------------------------------------------------------------------------
float LHSprite::animationDuration(){
    if(animation)return animation->totalTime();
    return 0.0f;
}
//------------------------------------------------------------------------------
void LHSprite::setFrame(int frmNo){ if(animation)animation->setFrame(frmNo);}
//------------------------------------------------------------------------------
int LHSprite::currentFrame(){
    if(animation) return animation->getCurrentFrame();
    return -1;
}
//------------------------------------------------------------------------------
void LHSprite::nextFrame(){ if(animation)animation->nextFrame();}
//------------------------------------------------------------------------------
void LHSprite::prevFrame(){ if(animation)animation->prevFrame();}
//------------------------------------------------------------------------------
void LHSprite::nextFrameAndRepeat(){ if(animation)animation->nextFrameAndRepeat();}
//------------------------------------------------------------------------------
void LHSprite::prevFrameAndRepeat(){ if(animation)animation->prevFrameAndRepeat();}
//------------------------------------------------------------------------------
bool LHSprite::isAtLastFrame(){ if(animation)return animation->isAtLastFrame();
    return false;
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
bool  LHSprite::removeBodyFromWorld(void){
    
    if(NULL != body){
		b2World* _world = body->GetWorld();
		if(0 != _world){
			_world->DestroyBody(body);
			body = NULL;
            
            return true;
		}
	}
    return false;
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
void LHSprite::transformPosition(CCPoint pos){
    setPosition(pos);
    if(0 != body)
    {
        b2Vec2 boxPosition = SpriteHelperLoader::pointsToMeters(pos);
        float angle = CC_DEGREES_TO_RADIANS(-1*getRotation());
        body->SetTransform(boxPosition, angle);
    }
}
//------------------------------------------------------------------------------
void LHSprite::transformRotation(float rot){
    setRotation(rot);
    if(0 != body)
    {
        b2Vec2 boxPosition = SpriteHelperLoader::pointsToMeters(getPosition());
        float angle = CC_DEGREES_TO_RADIANS(-1*rot);
        body->SetTransform(boxPosition, angle);
    }
}
//------------------------------------------------------------------------------
void LHSprite::transformScale(float scale){
    setScale(scale);
    if(0 != body){
        createFixturesFromInfoOnBody();
    }
}
//------------------------------------------------------------------------------
void LHSprite::transformScaleX(float scaleX){
    
    setScaleX(scaleX);
    
    if(0 != body){
        createFixturesFromInfoOnBody();
    }
    
}
//------------------------------------------------------------------------------
void LHSprite::transformScaleY(float scaleY){
    setScaleY(scaleY);
    
    if(0 != body){
        createFixturesFromInfoOnBody();
    }
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
bool LHSprite::isTouchedAtPoint(CCPoint point){
    
    if(body == NULL)
    {
        float x = point.x;
        float y = point.y;
        
        float ax = m_sQuad.tl.vertices.x;
        float ay = m_sQuad.tl.vertices.y;
        
        float bx = m_sQuad.tr.vertices.x;
        float by = m_sQuad.tr.vertices.y;
        
        float dx = m_sQuad.bl.vertices.x;
        float dy = m_sQuad.bl.vertices.y;
        
        float bax=bx-ax;
        float bay=by-ay;
        float dax=dx-ax;
        float day=dy-ay;
        
        if ((x-ax)*bax+(y-ay)*bay<0.0) return false;
        if ((x-bx)*bax+(y-by)*bay>0.0) return false;
        if ((x-ax)*dax+(y-ay)*day<0.0) return false;
        if ((x-dx)*dax+(y-dy)*day>0.0) return false;
        
        return true;
        
    }
    else{
        b2Fixture* stFix = body->GetFixtureList();
        while(stFix != 0){
            if(stFix->TestPoint(b2Vec2(point.x/LHSettings::sharedInstance()->lhPtmRatio(),
                                       point.y/LHSettings::sharedInstance()->lhPtmRatio()))){
                return true;
            }
            stFix = stFix->GetNext();
        }
    }
    return false;
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
std::string LHSprite::uniqueNameForBody(b2Body* body){
    
    CCNode* spr = (CCNode*)body->GetUserData();
    
    if(LHSprite::isLHSprite(spr))
        return ((LHSprite*)spr)->getUniqueName();
        
    return NULL;
}
//------------------------------------------------------------------------------
LHSprite* LHSprite::spriteForBody(b2Body* body){
    
    if(0 == body)
        return 0;
    
    CCNode* spr = (CCNode*)body->GetUserData();
    
    if(LHSprite::isLHSprite(spr))
    {
        return (LHSprite*)spr;
    }
    
    return 0;
}
//------------------------------------------------------------------------------
int LHSprite::tagForBody(b2Body* body){
    if(0 != body)
    {
        CCNode* spr = (CCNode*)body->GetUserData();
        if(NULL != spr)
        {
            return spr->getTag();
        }
    }
    return -1;
}
//------------------------------------------------------------------------------
bool LHSprite::isLHSprite(CCNode* obj){
    
    if( 0 != dynamic_cast<LHSprite*>(obj))
        return true;
    
    return false;
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
void LHSprite::setCollisionFilterCategory(int category){
    if(body == NULL)
        return;
    
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = (uint16)category;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = curFilter.groupIndex;
        
        curFix->SetFilterData(filter);
        curFix = curFix->GetNext();
    }
}
void LHSprite::setCollisionFilterMask(int mask){
    if(body == NULL)
        return;
    
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = (uint16)mask;
        filter.groupIndex   = curFilter.groupIndex;
        
        curFix->SetFilterData(filter);
        curFix = curFix->GetNext();
    }
}
void LHSprite::setCollisionFilterGroup(int group){
    if(body == NULL)
        return;
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = (int16)group;
        
        curFix->SetFilterData(filter);
        curFix = curFix->GetNext();
    }
}

//TYPE CONVERSION
//------------------------------------------------------------------------------
void LHSprite::makeDynamic(){
    
    if(body == NULL)
        return;
    
    body->SetType(b2_dynamicBody);
}
void LHSprite::makeStatic(){
    if(body == NULL)
        return;
    
    body->SetType(b2_staticBody);
}
void LHSprite::makeKinematic(){
    if(body == NULL)
        return;
    
    body->SetType(b2_kinematicBody);
}